<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随遇而安</title>
  
  <subtitle>昨昔一切如空，今昔一切如新</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-25T07:46:12.338Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>魏斌锋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8 Lambda 表达式</title>
    <link href="http://yoursite.com/2019/07/25/java8-Lambda/"/>
    <id>http://yoursite.com/2019/07/25/java8-Lambda/</id>
    <published>2019-07-25T02:31:56.000Z</published>
    <updated>2019-07-25T07:46:12.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h2><p>Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p><p>你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。  </p><p><div align="center"><img src="http://wx2.sinaimg.cn/small/005yW6Rhttp://wx2.sinaimg.cn/small/005yW6RRgy1g5bwluffblj306e06dgm2.jpg" alt="image">                           </div></p><p>Java 中的 Lambda 表达式通常使用 <code>(argument) -&gt; (body)</code> 语法书写，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class="line"></span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>以下是一些 Lambda 表达式的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h2><p>让我们了解一下 Lambda 表达式的结构。</p><ul><li>一个 Lambda 表达式可以有零个或多个参数   </li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同  </li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如<code>(a, b)</code>或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code>  </li><li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code>  </li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code><br><strong>Lambda 表达式的主体可包含零条或多条语句</strong><br>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致<br>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</li></ul><p><code>java.lang.Runnable</code> 就是一种函数式接口，在<code>Runnable</code> 接口中只声明了一个方法<code>void run()</code>，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p><p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure></p><p>当不指明函数式接口时，编译器会自动解释这种转化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">   () -&gt; System.out.println(<span class="string">"hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure></p><p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给<code>Runnable</code>接口。</p><p>以下是一些 Lambda 表达式及其函数式接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Consumer&lt;Integer&gt;  c = (<span class="keyword">int</span> x) -&gt; &#123; System.out.println(x) &#125;;</span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">" : "</span> + y);</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="keyword">null</span> &#125;;</span><br></pre></td></tr></table></figure></p><p><code>@FunctionalInterface</code> 是 Java 8 新加入的一种接口，<strong>用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口</strong>。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p><p>以下是一种自定义的函数式接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据定义，<strong>函数式接口只能有一个抽象方法</strong>，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeMoreWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unexpected <span class="meta">@FunctionalInterface</span> annotation </span><br><span class="line">    <span class="meta">@FunctionalInterface</span> ^ WorkerInterface is not a functional <span class="class"><span class="keyword">interface</span> <span class="title">multiple</span> </span></span><br><span class="line"><span class="class">    <span class="title">non</span>-<span class="title">overriding</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">found</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">WorkerInterface</span> 1 <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p><p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义一个函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(WorkerInterface worker)</span> </span>&#123;</span><br><span class="line">    worker.doSomeWork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Annonymous class</span></span><br><span class="line">    execute(<span class="keyword">new</span> WorkerInterface() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Worker invoked using Anonymous class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Lambda expression </span></span><br><span class="line">    execute( () -&gt; System.out.println(<span class="string">"Worker invoked using Lambda expression"</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker invoked using Anonymous <span class="class"><span class="keyword">class</span> </span></span><br><span class="line"><span class="class"><span class="title">Worker</span> <span class="title">invoked</span> <span class="title">using</span> <span class="title">Lambda</span> <span class="title">expression</span></span></span><br></pre></td></tr></table></figure></p><p>这上面的例子里，我们创建了自定义的函数式接口并与 Lambda 表达式一起使用。<code>execute()</code> 方法现在可以将 Lambda 表达式作为参数。</p><h2 id="Lambda-表达式举例"><a href="#Lambda-表达式举例" class="headerlink" title="Lambda 表达式举例"></a>Lambda 表达式举例</h2><p>学习 Lambda 表达式的最好方式是学习例子。</p><p>线程可以通过以下方法初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧方法:</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello from thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//新方法:</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello from thread"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure></p><p>事件处理可以使用 Java 8 的 Lambda 表达式解决。下面的代码中，我们将使用新旧两种方式向一个 UI 组件添加 ActionListener：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//Old way:</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"The button was clicked using old fashion code!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">button.addActionListener( (e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"The button was clicked. From Lambda expressions !"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以下代码的作用是打印出给定数组中的所有元素。注意，使用 Lambda 表达式的方法不止一种。在下面的例子中，我们先是用常用的箭头语法创建 Lambda 表达式，之后，使用 Java 8 全新的双冒号<code>(::)</code>操作符将一个常规方法转化为 Lambda 表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer n: list) &#123;</span><br><span class="line">   System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">list.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//or we can use :: double colon operator in Java 8</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>在下面的例子中，我们使用断言<code>(Predicate)</code>函数式接口创建一个测试，并打印所有通过测试的元素，这样，你就可以使用 Lambda 表达式规定一些逻辑，并以此为基础有所作为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] a)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Print all numbers:"</span>);</span><br><span class="line">    evaluate(list, (n)-&gt;<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Print no numbers:"</span>);</span><br><span class="line">    evaluate(list, (n)-&gt;<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Print even numbers:"</span>);</span><br><span class="line">    evaluate(list, (n)-&gt; n%<span class="number">2</span> == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Print odd numbers:"</span>);</span><br><span class="line">    evaluate(list, (n)-&gt; n%<span class="number">2</span> == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Print numbers greater than 5:"</span>);</span><br><span class="line">    evaluate(list, (n)-&gt; n &gt; <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer n: list)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Print all numbers: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </span><br><span class="line">Print no numbers: </span><br><span class="line">Print even numbers: <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line">Print odd numbers: <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> </span><br><span class="line">Print numbers greater than <span class="number">5</span>: <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>下面的例子使用 Lambda 表达式打印数值中每个元素的平方，注意我们使用了<code>.stream()</code> 方法将常规数组转化为流。Java 8 增加了一些超棒的流 APIs。<code>java.util.stream.Stream</code> 接口包含许多有用的方法，能结合 Lambda 表达式产生神奇的效果。我们将 Lambda 表达式 <code>x -&gt; x*x</code> 传给 <code>map()</code> 方法，该方法会作用于流中的所有元素。之后，我们使用 <code>forEach</code> 方法打印数据中的所有元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().map((x) -&gt; x*x).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>下面的例子会计算给定数值中每个元素平方后的总和。请注意，Lambda 表达式只用一条语句就能达到此功能，这也是 <code>MapReduce</code> 的一个初级例子。我们使用 <code>map()</code> 给每个元素求平方，再使用 <code>reduce()</code> 将所有元素计入一个数值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    sum = sum + x;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure></p><h2 id="Java-8-Stream"><a href="#Java-8-Stream" class="headerlink" title="Java 8 Stream"></a>Java 8 Stream</h2><p><code>Java 8 API</code>添加了一个新的抽象称为流<code>Stream</code>，可以让你以一种声明的方式处理数据。</p><p><code>Stream</code> 使用一种类似用 <code>SQL</code> 语句从数据库查询数据的直观方式来提供一种对 <code>Java</code> 集合运算和表达的高阶抽象。</p><p><code>Stream API</code>可以极大提高<code>Java</code>程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， <strong>并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</strong></p><p>元素流在管道中经过中间操作<code>（intermediate operation）</code> 的处理，最后由最终操作<code>(terminal operation)</code> 得到前面处理的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure></p><p>以上的流程转换为 Java 代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure></p><h3 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h3><p><code>Stream（流）</code> 是一个来自数据源的元素队列并支持聚合操作</p><ul><li><strong>元素</strong>是特定类型的对象，形成一个队列。 Java中的<code>Stream</code> 并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，<code>I/O</code> <code>channel</code>， 产生器<code>generator</code> 等。</li><li><p><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如<code>filter, map, reduce, find, match, sorted</code>等。<br>和以前的<code>Collection</code>操作不同， <code>Stream</code>操作还有两个基础的特征：</p></li><li><p><code>Pipelining</code> 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格<code>（fluent style）</code>。 这样做可以对操作进行优化， 比如延迟执行<code>(laziness)</code>和短路<code>( short-circuiting)</code>。  </p></li><li>内部迭代： 以前对集合遍历都是通过<code>Iterator</code>或者<code>For-Each</code>的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 <code>Stream</code>提供了内部迭代的方式， 通过访问者模式<code>(Visitor)</code>实现。<h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4>在 Java 8 中, 集合接口有两个方法来生成流：</li></ul><p><code>stream()</code> − 为集合创建串行流。</p><p><code>parallelStream()</code> − 为集合创建并行流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">forEach</span><br></pre></td></tr></table></figure></p><p>Stream 提供了新的方法 <code>forEach</code> 来迭代流中的每个数据。以下代码片段使用 <code>forEach</code> 输出了10个随机数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code> 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p><code>filter</code> 方法用于通过设置的条件过滤出元素。以下代码片段使用 <code>filter</code> 方法过滤出空字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code> 方法用于获取指定数量的流。 以下代码片段使用 <code>limit</code> 方法打印出 10 条数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code> 方法用于对流进行排序。以下代码片段使用 <code>sorted</code> 方法对输出的 10 个随机数进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h4 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h4><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><p>我们可以很容易的在顺序运行和并行直接切换。</p><h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p><code>Collectors</code> 类实现了很多归约操作，例如<strong>将流转换成集合和聚合元素</strong>。<code>Collectors</code> 可用于<strong>返回列表或字符串</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure></p><h4 id="使用Stream实现分页排序"><a href="#使用Stream实现分页排序" class="headerlink" title="使用Stream实现分页排序"></a>使用Stream实现分页排序</h4><p>使用Stream可以实现一些复杂的操作，例如使用 <code>sorted,skip,limit</code> 进行分页排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序并分页 时间倒叙</span></span><br><span class="line">     List &lt; VideoParamWithLikes &gt; collect = likesList.stream().sorted(Comparator.comparing(VideoParamWithLikes::getLikeTime).reversed()).</span><br><span class="line">skip(((page-<span class="number">1</span>)*<span class="number">20</span>)).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于<code>int、double、long</code>等基本类型上，它们可以用来产生类似如下的统计结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure></p><h2 id="Stream-完整实例"><a href="#Stream-完整实例" class="headerlink" title="Stream 完整实例"></a>Stream 完整实例</h2><p>将以下代码放入 Java8Tester.java 文件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">Java8Tester.java 文件</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.IntSummaryStatistics;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"使用 Java 7: "</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 计算空字符串</span></span><br><span class="line">      List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">      System.out.println(<span class="string">"列表: "</span> +strings);</span><br><span class="line">      <span class="keyword">long</span> count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"空字符数量为: "</span> + count);</span><br><span class="line">      count = getCountLength3UsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"字符串长度为 3 的数量为: "</span> + count);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 删除空字符串</span></span><br><span class="line">      List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(<span class="string">"筛选后的列表: "</span> + filtered);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 删除空字符串，并使用逗号把它们合并起来</span></span><br><span class="line">      String mergedString = getMergedStringUsingJava7(strings,<span class="string">", "</span>);</span><br><span class="line">      System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 获取列表元素平方数</span></span><br><span class="line">      List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">      System.out.println(<span class="string">"平方数列表: "</span> + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">8</span>,<span class="number">19</span>);</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"列表: "</span> +integers);</span><br><span class="line">      System.out.println(<span class="string">"列表中最大的数 : "</span> + getMax(integers));</span><br><span class="line">      System.out.println(<span class="string">"列表中最小的数 : "</span> + getMin(integers));</span><br><span class="line">      System.out.println(<span class="string">"所有数之和 : "</span> + getSum(integers));</span><br><span class="line">      System.out.println(<span class="string">"平均数 : "</span> + getAverage(integers));</span><br><span class="line">      System.out.println(<span class="string">"随机数: "</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 输出10个随机数</span></span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"使用 Java 8: "</span>);</span><br><span class="line">      System.out.println(<span class="string">"列表: "</span> +strings);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(<span class="string">"空字符串数量为: "</span> + count);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string -&gt; string.length() == <span class="number">3</span>).count();</span><br><span class="line">      System.out.println(<span class="string">"字符串长度为 3 的数量为: "</span> + count);</span><br><span class="line">        </span><br><span class="line">      filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(<span class="string">"筛选后的列表: "</span> + filtered);</span><br><span class="line">        </span><br><span class="line">      mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">      System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br><span class="line">        </span><br><span class="line">      squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(<span class="string">"Squares List: "</span> + squaresList);</span><br><span class="line">      System.out.println(<span class="string">"列表: "</span> +integers);</span><br><span class="line">        </span><br><span class="line">      IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">      System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">      System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">      System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br><span class="line">      System.out.println(<span class="string">"随机数: "</span>);</span><br><span class="line">        </span><br><span class="line">      random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 并行处理</span></span><br><span class="line">      count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(<span class="string">"空字符串的数量为: "</span> + count);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCountEmptyStringUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCountLength3UsingJava7</span><span class="params">(List&lt;String&gt; strings)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(string.length() == <span class="number">3</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">deleteEmptyStringsUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span></span>&#123;</span><br><span class="line">      List&lt;String&gt; filteredList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> filteredList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMergedStringUsingJava7</span><span class="params">(List&lt;String&gt; strings, String separator)</span></span>&#123;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString = stringBuilder.toString();</span><br><span class="line">      <span class="keyword">return</span> mergedString.substring(<span class="number">0</span>, mergedString.length()-<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getSquares</span><span class="params">(List&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(Integer number: numbers)&#123;</span><br><span class="line">         Integer square = <span class="keyword">new</span> Integer(number.intValue() * number.intValue());</span><br><span class="line">            </span><br><span class="line">         <span class="keyword">if</span>(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> squaresList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(List&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> max = numbers.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">            </span><br><span class="line">         <span class="keyword">if</span>(number.intValue() &gt; max)&#123;</span><br><span class="line">            max = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(List&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> min = numbers.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(number.intValue() &lt; min)&#123;</span><br><span class="line">            min = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> min;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(List numbers)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = (<span class="keyword">int</span>)(numbers.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum += (<span class="keyword">int</span>)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAverage</span><span class="params">(List&lt;Integer&gt; numbers)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getSum(numbers) / numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行以上脚本，输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java <span class="number">7</span>: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: <span class="number">2</span></span><br><span class="line">字符串长度为 <span class="number">3</span> 的数量为: <span class="number">3</span></span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [<span class="number">9</span>, <span class="number">4</span>, <span class="number">49</span>, <span class="number">25</span>]</span><br><span class="line">列表: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">19</span>]</span><br><span class="line">列表中最大的数 : <span class="number">19</span></span><br><span class="line">列表中最小的数 : <span class="number">1</span></span><br><span class="line">所有数之和 : <span class="number">85</span></span><br><span class="line">平均数 : <span class="number">9</span></span><br><span class="line">随机数: </span><br><span class="line">-<span class="number">393170844</span></span><br><span class="line">-<span class="number">963842252</span></span><br><span class="line"><span class="number">447036679</span></span><br><span class="line">-<span class="number">1043163142</span></span><br><span class="line">-<span class="number">881079698</span></span><br><span class="line"><span class="number">221586850</span></span><br><span class="line">-<span class="number">1101570113</span></span><br><span class="line"><span class="number">576190039</span></span><br><span class="line">-<span class="number">1045184578</span></span><br><span class="line"><span class="number">1647841045</span></span><br><span class="line">使用 Java <span class="number">8</span>: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: <span class="number">2</span></span><br><span class="line">字符串长度为 <span class="number">3</span> 的数量为: <span class="number">3</span></span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [<span class="number">9</span>, <span class="number">4</span>, <span class="number">49</span>, <span class="number">25</span>]</span><br><span class="line">列表: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">19</span>]</span><br><span class="line">列表中最大的数 : <span class="number">19</span></span><br><span class="line">列表中最小的数 : <span class="number">1</span></span><br><span class="line">所有数之和 : <span class="number">85</span></span><br><span class="line">平均数 : <span class="number">9.444444444444445</span></span><br><span class="line">随机数: </span><br><span class="line">-<span class="number">1743813696</span></span><br><span class="line">-<span class="number">1301974944</span></span><br><span class="line">-<span class="number">1299484995</span></span><br><span class="line">-<span class="number">779981186</span></span><br><span class="line"><span class="number">136544902</span></span><br><span class="line"><span class="number">555792023</span></span><br><span class="line"><span class="number">1243315896</span></span><br><span class="line"><span class="number">1264920849</span></span><br><span class="line"><span class="number">1472077135</span></span><br><span class="line"><span class="number">1706423674</span></span><br><span class="line">空字符串的数量为: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda-表达式简介&quot;&gt;&lt;a href=&quot;#Lambda-表达式简介&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式简介&quot;&gt;&lt;/a&gt;Lambda 表达式简介&lt;/h2&gt;&lt;p&gt;Lambda 表达式是一种匿名函数(对 Java 而言这并不
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="Lambda 表达式" scheme="http://yoursite.com/tags/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java 8的java.time包</title>
    <link href="http://yoursite.com/2019/07/25/java8-time/"/>
    <id>http://yoursite.com/2019/07/25/java8-time/</id>
    <published>2019-07-25T01:33:04.000Z</published>
    <updated>2019-07-25T02:18:20.406Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p><p>&ensp;1.1 Java的java.util.Date和java.util.Calendar类易用性差，不支持时区，而且他们都不是线程安全的；<br>&ensp;1.2 用于格式化日期的类DateFormat被放在java.text包中，它是一个抽象类，所以我1 们需要实例化一个SimpleDateFormat对象来处理日期格式化，并且DateFormat也是非线程安全，这意味着如果你在多线程程序中调用同一个DateFormat对象，会得到意想不到的结果。<br>&ensp;1.3对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从Calendar中获取的月份需要加一才能表示当前月份。<br>&ensp;由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是JSR-310规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p><h2 id="Java-8-日期时间-API"><a href="#Java-8-日期时间-API" class="headerlink" title="Java 8 日期时间 API"></a>Java 8 日期时间 API</h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API</p><p> Local(本地) − 简化了日期时间的处理，没有时区的问题。</p><ul><li><p>Zoned(时区) − 通过制定的时区处理日期时间。</p></li><li><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作，下面我们看看这些类的用法。  </p><h3 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h3><p>LocalDate类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过LocalDate的静态方法of()创建一个实例，LocalDate也包含一些方法用来获取年份，月份，天，星期几等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">24</span>);   <span class="comment">//初始化一个自定义期：2019-07-24</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();                     <span class="comment">// 年份：2019</span></span><br><span class="line">Month month = localDate.getMonth();                 <span class="comment">// 月份：JULY</span></span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();         <span class="comment">// 月份中的第几天：24</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();     <span class="comment">// 一周的第几天：WEDNESDAY</span></span><br><span class="line"><span class="keyword">int</span> length = localDate.lengthOfMonth();             <span class="comment">// 月份的天数：31</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = localDate.isLeapYear();          <span class="comment">// 是否为闰年：false</span></span><br><span class="line">LocalDate localDate  = LocalDate.now();             <span class="comment">//获取当前日期 2019-07-23</span></span><br></pre></td></tr></table></figure></li></ul><p>LocalTime和LocalDate类似，他们之间的区别在于<strong>LocalDate不包含具体时间</strong>，而<strong>LocalTime包含具体时间</strong>，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);     <span class="comment">// 初始化一个自定义时间：17:23:52</span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();                     <span class="comment">// 时：17</span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();                 <span class="comment">// 分：23</span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();                 <span class="comment">// 秒：52</span></span><br></pre></td></tr></table></figure></p><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime类是<strong>LocalDate和LocalTime的结合体</strong>，可以通过of()方法直接创建，也可以调用LocalDate的atTime()方法或LocalTime的atDate()方法将LocalDate或LocalTime合并成一个LocalDateTime：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2019</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br></pre></td></tr></table></figure></p><p>LocalDateTime也提供用于向LocalDate和LocalTime的转化：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = ldt1.toLocalDate();</span><br><span class="line">LocalTime time = ldt1.toLocalTime();</span><br></pre></td></tr></table></figure></p><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure><p>ofEpochSecond()方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻，控制台上的输出为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">02</span>:<span class="number">00.000100</span>Z</span><br></pre></td></tr></table></figure></p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>Duration的内部实现与Instant类似，也是包含两部分：seconds表示秒，nanos表示纳秒。<strong>两者的区别是Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段</strong>，所以Duration类中不包含now()静态方法。可以通过Duration.between()方法创建Duration对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of(<span class="number">2019</span>, Month.JANUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);    <span class="comment">// 2019-01-05 10:07:00</span></span><br><span class="line">LocalDateTime to = LocalDateTime.of(<span class="number">2019</span>, Month.FEBRUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);     <span class="comment">// 2019-02-05 10:07:00</span></span><br><span class="line">Duration duration = Duration.between(from, to);     <span class="comment">// 表示从 2019-01-05 10:07:00 到 2019-02-05 10:07:00 这段时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br></pre></td></tr></table></figure></p><p>Duration对象还可以通过of()方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：<br>Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天<br>Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒  </p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>Period在概念上和Duration类似，区别在<strong>于Period是以年月日来衡量一个时间段</strong>，比如2年3个月6天：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><p> Period对象也可以通过between()方法创建，值得注意的是，由于Period是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 2019-01-05 到 2019-02-05 这段时间</span></span><br><span class="line">Period period = Period.between(</span><br><span class="line">                LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">                LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure></p><h2 id="日期的操作和格式化"><a href="#日期的操作和格式化" class="headerlink" title="日期的操作和格式化"></a>日期的操作和格式化</h2><h3 id="增加和减少日期"><a href="#增加和减少日期" class="headerlink" title="增加和减少日期"></a>增加和减少日期</h3><p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">5</span>);          <span class="comment">// 2019-01-05</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2020</span>);              <span class="comment">// 修改为 2020-01-05</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2019-02-05</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2019-01-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2018-01-05</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2016-11-05</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2019-01-10</span></span><br></pre></td></tr></table></figure><p> 上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用with()方法的另一个重载方法，它接收一个TemporalAdjuster参数，可以使我们更加灵活的调整日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure></p><p> 要使上面的代码正确编译，你需要使用<strong>静态导入TemporalAdjusters对象</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</span><br></pre></td></tr></table></figure></p><p> TemporalAdjusters类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>dayOfWeekInMonth</td><td>返回同一个月中每周的第几天</td></tr><tr><td>firstDayOfMonth</td><td>返回当月的第一天</td></tr><tr><td>firstDayOfNextMonth</td><td>返回下月的第一天</td></tr><tr><td>firstDayOfNextYear</td><td>返回下一年的第一天</td></tr><tr><td>firstDayOfYear</td><td>返回本年的第一天</td></tr><tr><td>firstInMonth</td><td>返回同一个月中第一个星期几</td></tr><tr><td>lastDayOfMonth</td><td>返回当月的最后一天</td></tr><tr><td>lastDayOfNextMonth</td><td>返回下月的最后一天</td></tr><tr><td>lastDayOfNextYear</td><td>返回下一年的最后一天</td></tr><tr><td>lastDayOfYear</td><td>返回本年的最后一天</td></tr><tr><td>lastInMonth</td><td>返回同一个月中最后一个星期几</td></tr><tr><td>next / previous</td><td>返回后一个/前一个给定的星期几</td></tr><tr><td>nextOrSame / previousOrSame</td><td>返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td></tr></tbody></table><p>如果上面表格中列出的方法不能满足你的需求，你还可以<strong>创建自定义的TemporalAdjuster接口的实现</strong>，TemporalAdjuster也是一个函数式接口，所以我们可以使用Lambda表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">date.with(temporal -&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下，每次增加一天</span></span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期五，增加三天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期六，增加两天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><p>新的日期API中提供了一个DateTimeFormatter类用于处理日期格式化操作，它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串，该方法接收一个DateTimeFormatter类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">// 20190105</span></span><br><span class="line">String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    <span class="comment">// 2019-01-05</span></span><br><span class="line">String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    <span class="comment">// 14:20:16.998</span></span><br><span class="line">String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));   <span class="comment">// 2019-01-05</span></span><br><span class="line">String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"今天是：YYYY年 MMMM DD日 E"</span>, Locale.CHINESE)); <span class="comment">// 今天是：2019年 一月 05日 星期六</span></span><br></pre></td></tr></table></figure><p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String strDate6 = <span class="string">"2019-01-05"</span>;</span><br><span class="line">String strDate7 = <span class="string">"2019-01-05 12:30:05"</span>;</span><br><span class="line">LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br></pre></td></tr></table></figure></p><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>Java 8中的时区操作被很大程度上简化了，新的时区类java.time.ZoneId是原有的java.util.TimeZone类的替代品。ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure></p><p> of()方法接收一个“区域/城市”的字符串作为参数，你可以通过getAvailableZoneIds()方法获取所有合法的“区域/城市”字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure></p><p> 对于老的时区类TimeZone，Java 8也提供了转化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure></p><p>有了ZoneId，我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</span><br></pre></td></tr></table></figure></p><p>ZonedDateTime对象由两部分构成，LocalDateTime和ZoneId，其中2017-01-05T15:26:56.147部分为LocalDateTime，+08:00[Asia/Shanghai]部分为ZoneId。<br>另一种表示时区的方式是使用ZoneOffset，它是<strong>以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算</strong>，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure></p><h2 id="其他历法"><a href="#其他历法" class="headerlink" title="其他历法"></a>其他历法</h2><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p><p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p><ul><li>ThaiBuddhistDate：泰国佛教历</li><li>MinguoDate：中华民国历</li><li>JapaneseDate：日本历</li><li>HijrahDate：伊斯兰历<br>每个日期类都继承ChronoLocalDate类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</li></ul><p>这些不同的历法也可以用于向公历转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">JapaneseDate jpDate = JapaneseDate.from(date);</span><br></pre></td></tr></table></figure></p><p>由于它们都继承ChronoLocalDate类，所以在不知道具体历法情况下，可以通过ChronoLocalDate类操作日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);</span><br><span class="line">ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();</span><br></pre></td></tr></table></figure></p><p>我们在开发过程中应该尽量避免使用ChronoLocalDate，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p><p>在实际开发过程中建议使用LocalDate，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用ChronoLocalDate类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：&lt;/p&gt;
&lt;p&gt;&amp;ensp;1.1 Java的ja
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/19/hello-world/"/>
    <id>http://yoursite.com/2019/07/19/hello-world/</id>
    <published>2019-07-19T01:44:26.066Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
